import Link from 'next/link'

import Button from '../../../components/button.js'

export const metadata = {
  title: 'Using Anki to Study Medicine',
  subtitle: 'How I use flashcards for efficient study',
  description: '',
  emoji: 'ðŸ¥',
  date: '2020-07-07',
  category: ['medicine']
};

take the video in messages - send to yourself
copy video from messages on mac

cut to length
FCP - export as image sequence - imovie doesnt work

```bash ZSH
ffmpeg -framerate 60 -i /Users/reuben/Developer/next/reu-test/public/fcp/me-cut/frame-%06d.tiff -c:v libvpx-vp9 -pix_fmt yuva420p -speed 0 -crf 16 -an /Users/reuben/Developer/next/reu-test/public/me-cut.webm
ffmpeg -framerate 60 -i /Users/reuben/Developer/next/reu-test/public/fcp/me-cut/frame-%06d.tiff -c:v libvpx-vp9 -pix_fmt yuva420p -speed 0 -lossless 1 -an /Users/reuben/Developer/next/reu-test/public/me-cut.webm
```


chrome too laggy lowered FPS lowered CRF, no difference - maybe as codecs' efficiency relies on the compression being done in a forwards direction frame after frame only (there was more lag moving backwards)
safari fine - h265 better????

tried vp8 - no difference
https://stackoverflow.com/questions/31196113/draw-video-frame-by-frame-on-html5-canvas-and-control-with-slider


better to use image sequence tiff didnt work png better


wrote swift tool uPVC

https://stackoverflow.com/a/39573702

65.4MB in
reduce number of frames by 3 - nodejs script (redid swift tho)
imageoptim - reduce by..... 47% not helped by fact png doesnt enocde high fidelity well - need alpha channel tho.....led to webp

didnt go for avif as support is shite
webp - reduce by..... lossless=4.6MB; near-lossless60=3.6MB near-lossless0=3.3MB q100=2.2MB q90=1.3MB q80=868KB q50=868KB ALSO
https://developers.google.com/speed/webp/docs/cwebp
1.3272171254% of input = 98.6727828746% reduction

less when gzipped????

```bash ZSH
for file in *.png; do cwebp -lossless -mt './$file' -o './${file//\.png/.webp}'; done
for file in *.png; do cwebp -near_lossless 60 -mt './$file' -o './${file//\.png/.webp}'; done
for file in *.png; do cwebp -q 80 -mt './$file' -o './${file//\.png/.webp}'; done
for file in *.png; do cwebp -q 80 -mt -crop 100 26 459 350 './$file' -o './${file//\.png/.webp}'; done
```


webp is based off VP8 so basically gone full circle to the (very close) to VP9 of the first attempt

animated webp exists but isn't obvious way to seek through - probably has same encoding issues as VP8 itself


```swift Swift
//
//  main.swift
//  uPVC
//
//  Created by Reuben on 10/11/2020.
//  Copyright Â© 2020 Reuben. All rights reserved.
//

import Foundation
import AVFoundation

let arguments = Array(CommandLine.arguments[1...])
var stderr = StandardErrorOutputStream()

if(arguments.count == 0) {print('need a file', to: &stderr); exit(1)}

let videoPath = arguments[0]
let frameSkip = arguments.count > 1 ? Int(arguments[1]) : nil

let videoURL = URL(fileURLWithPath: videoPath)

let asset = AVAsset(url: videoURL)
let reader = try? AVAssetReader(asset: asset)

if(reader == nil) {print('sure this is a media file?', to: &stderr); exit(1)}

let videoTracks = asset.tracks(withMediaType: AVMediaType.video)

if(videoTracks.count == 0) {print('sure this is a video file?', to: &stderr); exit(1)}

let videoTrack = videoTracks[0]

let trackReaderOutput = AVAssetReaderTrackOutput(track: videoTrack, outputSettings:[String(kCVPixelBufferPixelFormatTypeKey): NSNumber(value: kCVPixelFormatType_32BGRA)])

reader!.add(trackReaderOutput)
reader!.startReading()

var frameIndex = 0

while let sampleBuffer = trackReaderOutput.copyNextSampleBuffer() {
  if((frameSkip != nil) && ((frameIndex % frameSkip!) == 0)) {
    if let imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer) {
      let ciimage: CIImage = CIImage(cvPixelBuffer: imageBuffer)

      if let colorSpace = CGColorSpace(name: CGColorSpace.sRGB) {
        do {
          let format = CIFormat.RGBA16 // 16-bit RGBA
          let quality = 1.0 // 1.0 = lossless

          let outFolderURL = videoURL.deletingPathExtension()
          let outURL = outFolderURL.appendingPathComponent('frame-\(frameIndex).png')

          let context = CIContext()

          try FileManager.default.createDirectory(at: outFolderURL, withIntermediateDirectories: true, attributes: nil)
          try context.writePNGRepresentation(of: ciimage, to: outURL, format: format, colorSpace: colorSpace, options: [kCGImageDestinationLossyCompressionQuality as CIImageRepresentationOption: quality])
        } catch {
          print(error.localizedDescription, to: &stderr)
        }
      }
    }
  }
  frameIndex += 1
}

final class StandardErrorOutputStream: TextOutputStream {
  func write(_ string: String) {
    FileHandle.standardError.write(Data(string.utf8))
  }
}
```
